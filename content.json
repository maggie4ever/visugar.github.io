{"meta":{"title":"Visugar个人博客","subtitle":"书写前端，记录心情，以及碎碎念 ~","description":"前端技术，个人博客，记录心情,visugar","author":"张小花","url":"http://visugar.com"},"pages":[{"title":"","date":"2017-05-18T09:08:15.602Z","updated":"2017-05-06T12:16:34.248Z","comments":true,"path":"404.html","permalink":"http://visugar.com/404.html","excerpt":"","text":"404"},{"title":"关于我","date":"2017-05-04T03:35:11.000Z","updated":"2017-07-31T11:11:26.321Z","comments":true,"path":"about/index.html","permalink":"http://visugar.com/about/index.html","excerpt":"","text":"爱捣腾爱码字爱购物爱看剧爱五月天的可是啥也不会的女汉纸一枚 快向我丢辣条啦啦啦啦 ~"},{"title":"更新日志","date":"2017-05-04T02:00:11.000Z","updated":"2017-06-09T12:35:30.221Z","comments":true,"path":"board/index.html","permalink":"http://visugar.com/board/index.html","excerpt":"","text":"2017-06-09《原生JS实现省市区（县）三级联动选择》 发布 2017-06-08《select表单元素详解及下拉列表模拟实现》 发布 2017-05-17《CSS3饼状loading效果 》 发布 2017-05-11《RegExp（正则表达式）常用要点小结》 发布 2017-05-10《中文技术文档规范-改自阮一峰老师》 发布 2017-05-06《菜鸟张小花之多种前端布局实现》发布 2017-05-04《hexo从零开始到搭建完整》的完成 2017-05-04使用hexo搭建博客，使用的主题是hueman，有很多地方还不完善，后期继续努力！"}],"posts":[{"title":"CSS3自定义滚动条样式","slug":"20170818CustomScroll","date":"2017-08-18T11:43:01.000Z","updated":"2017-08-18T11:45:23.854Z","comments":true,"path":"2017/08/18/20170818CustomScroll/","link":"","permalink":"http://visugar.com/2017/08/18/20170818CustomScroll/","excerpt":"","text":"写在前面滚动条是个很常见的东东，不过某些浏览器自带的滚动条确实不太好看啊，下面可以作为学习，探讨下自定义滚动条的实现，这样你的滚动条就可以美美的啦。但是，也只能玩玩，因为只针对webkit内核的浏览器啊啊啊啊啊！ overflow介绍定义：overflow 属性指定当它溢出其块级容器时,是否剪辑内容，渲染滚动条或显示内容。 属性值12345overflow:visible //默认值。内容不会被修剪，超出内容会显示在元素框之外overflow:hidden //内容会被修剪。超出内容被隐藏overflow:scroll //内容会被修剪，浏览器会显示滚动条以便查看其余内容overflow:auto //如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。overflow:inherit //规定从该父元素继承overflow属性的值 注：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 当overflow设为除默认值（visible）以外的值时，将会创建一个会块级式化上下文（清除浮动的一种方式），更多可查看深入理解BFC和Margin Collapse 小tips 对于当行文本对超出部分的处理可使用一下属性。（同时需设置元素的width值，还有overflow:hidden;及white-space:nowrap;)123text-overflow:clip //修剪文本。text-overflow:ellipsis //显示省略符号来代表被修剪的文本。text-overflow:string //使用给定的字符串来代表被修剪的文本。 对于多行文本则需要用到不规范属性-webkit-line-clamp，此处不细讲。点击此处参考 水平及垂直滚动条使用overflow-x和overflow-y可分别设置水平及垂直方向上的滚动条。 自定义滚动条实现此部分针对webkit内核的浏览器，使用伪类来改变滚动条的默认样式，详情如下：滚动条组成部分12345671. ::-webkit-scrollbar 滚动条整体部分2. ::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或向左向右移动）3. ::-webkit-scrollbar-track 滚动条的轨道（里面装有Thumb）4. ::-webkit-scrollbar-button 滚动条的轨道的两端按钮，由于通过点击微调小方块的位置。5. ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分6. ::-webkit-scrollbar-corner 边角，即垂直滚动条和水平滚动条相交的地方7. ::-webkit-resizer 两个滚动条的交汇处上用于拖动调整元素大小的小控件 滚动条组成结构图如下： 下面来一组简单自定义滚动条的实现：1234567891011121314151617181920212223242526272829&lt;div class=&quot;box box7&quot;&gt; &lt;p&gt;这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要， 用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也 会出现滚动条。 这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要， 用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也 会出现滚动条。 &lt;/p&gt;&lt;/div&gt;.box8::-webkit-scrollbar &#123; width: 12px; background-color: #eee;&#125;.box8::-webkit-scrollbar-track &#123; background-color: #eee;&#125;.box8::-webkit-scrollbar-thumb &#123; background: #3DB6A4;&#125;.box8::-webkit-scrollbar-button:start &#123; background: url(./imgs/up.png) no-repeat; background-size: 12px 12px;&#125;.box8::-webkit-scrollbar-button:end &#123; background: url(./imgs/down.png) no-repeat; background-size: 12px 12px;&#125; 更多效果如下图： 注意只在chrome下有效！！！！！！ 源码地址 预览地址 小结 无法兼容各大浏览器，只能在chrome下耍耍 本文仅作参考，更多内容请看参考资料 参考资料 CSS3自定义滚动条样式 -webkit-scrollbar overflow-MDN","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://visugar.com/tags/css/"},{"name":"scrollbar","slug":"scrollbar","permalink":"http://visugar.com/tags/scrollbar/"}]},{"title":"Web Animations API (JS动画利器)","slug":"20170809WebAnimations","date":"2017-08-09T11:01:03.000Z","updated":"2017-08-09T11:06:33.814Z","comments":true,"path":"2017/08/09/20170809WebAnimations/","link":"","permalink":"http://visugar.com/2017/08/09/20170809WebAnimations/","excerpt":"","text":"写在前面之前学习了CSS animation/setTimeout/setInterval/requestAnimationFrame等，这些都可以用在某种场景下的小动画，也可以说是动效。CSS动画君居然强大，但是缺陷也很多啊，有的时候没法满足要求，定时器用在动画中就更不使用了，但是requestAnimationFrame也是个很强大的东西，具体详情移步到window.requestAnimationFrame关于动画，你需要知道的 requestAnimationFrame-张鑫旭这几篇文章。下面做的笔记是关于Web Animations API (WAAPI)的，也就是js中的animate。 web animations API对于waapi，可能大家对css animation更熟悉，下面先看下css animation的用法：12345678910111213141516171819202122232425.item1&#123; animation: rotate 4s inifite ease running;&#125;@keyframes rotate&#123; from&#123; transform：rotate(0); &#125; to&#123; transform:rotate(360deg); &#125;&#125;或者@keyframes rotate&#123; 0%&#123; transform：rotate(0); background-color：red; &#125; 40%&#123; background-color：blue; &#125; 100%&#123; transform:rotate(360deg); background-color:red; &#125;&#125; 平时用的较多的是百分比类型的，可以定义多个关键帧。下面来看看waapi版本的：123456789101112var ani1 = [ &#123;transform:&apos;rotate(0)&apos;,backgroundColor:&apos;red&apos;&#125;, &#123;backgroundColor:&apos;blue&apos;,offset:0.4&#125;, &#123;transform:&apos;rotate(360deg)&apos;,backgroundColor:&apos;red&apos;&#125; ]; var aniOpt1 = &#123; duration:4000, iterations:Infinity, easing:&apos;ease-in-out&apos; &#125;; document.querySelector(&quot;.item1&quot;).animate(ani1,aniOpt1); Element.animate() 元素调用后会立即执行。跟css3动画有点类似但是有很多小区别，列如： css3动画中用的时间单位为s，而wappi中使用的与setTimeout等定时器的单位及写法一致（单位为ms且可省略） waapi中关键帧的值传入的是字符串类型，与css3不一样。 waapi中不再有百分数，而是用offset来设置关键帧的位置。 css3动画中animation-duration变为duriation，animation-iteration-count则变成iterations，且其无限次的值由字符串’infinite’变成关键字Infinity。等等还有其他一些元素的改变，从单词来讲变得更简洁了。 如果只需设置duration属性，则可采用下面这种更简洁的方式：1document.querySelector(&quot;.item1&quot;).animate(ani1,4000); document.animate()可以应用在任何可以使用CSS动画的DOM元素上，下面是几个waapi更强大的控制方法： play()，pause()，reverse()和playbackRate控制播放123var rotateAni = document.querySelector(&quot;.item1&quot;).animate(ani1,aniOpt1);rotateAni.play() //播放rotateAni.pause() //暂停 注：在动画执行的时候可以在控制台打印下rotateAni，能够看到rotateAni所带的一些属性值及原型上的方法(此时playbackRate的值为1)。 然后发现除了上面这几个之外还有一些其他的属性及方法，再挑几个说一下：123finish() //对于有限次的动画而言，直接停止动画，且跳到动画结束位置cancel() //取消动画过程，直接跳到动画的开始位置reverse() //让动画反向执行到动画执行的原点,会将playbackTate从1变成-1 playbackRate属性reverse()方法可将playbackRate的值改变。如果手动将playbackRate改成一个0-1之间的数值，则可将动画慢下来。设成大于1的值则可使动画加速。 获取动画信息还有一些方法尚在实验中额，等浏览器可支持后再用起来。。。 wappi的事件监听123456789onfinish:用于注册完成事件，当调用finish()方法是也可以触发。oncancel:用于注册取消事件，当调用cancel()方法是也可以触发。rotateAni.onfinish = function()&#123; doSomething();&#125;rotateAni.oncancel = function()&#123; doSomething();&#125; 浏览器支持度一图胜前言can i use 小结 由于目前浏览器支持度不算高，所以呢还是要慎用。 在现代浏览器中，使用wappi可以做出很酷的动画，可以多试试。 本文也只算是学习笔记，所以欢迎大佬们指点额~ 参考资料 WAAPI-w3cplus web animations-w3cplus Web Animations API-MDN","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"动画","slug":"动画","permalink":"http://visugar.com/tags/动画/"},{"name":"js","slug":"js","permalink":"http://visugar.com/tags/js/"}]},{"title":"Hexo博客添加SEO-评论系统-阅读统计-站长统计","slug":"20170801HexoPlugins","date":"2017-08-01T11:49:26.000Z","updated":"2017-08-31T10:18:28.050Z","comments":true,"path":"2017/08/01/20170801HexoPlugins/","link":"","permalink":"http://visugar.com/2017/08/01/20170801HexoPlugins/","excerpt":"","text":"写在前面在五月出捣腾了一把个人博客，但是刚开始只做了一些基础设置，套路也没摸清，基础安装篇请看hexo从零开始到搭建完整,里面讲到了基础工具的安装及blog项目的文件夹含义，以及RSS添加、域名的绑定等操作，后来想着加点功能，但是奈何我选的主题集成的东西比较少，需要一比一步自己添加，于是摸索了一番。。。现在真是发现了next主题的好处，不仅持续更新，而且作者已经在主题中集成了各种功能，简直爽歪歪，不过我还是默默的接着摸索吧！下面介绍几种好用的东西。 推荐七牛云 添加百度SEO 添加谷歌SEO 添加评论系统来必力 百度统计 文章统计leanCloud 引入站长统计不蒜子 七牛云先给大兄弟们极力推荐个好用的图床工具七牛云。么么注：上传后的图片尽量不要修改和删除额，不然之前添加的链接就会失效啦 添加百度SEO为了增加文章的曝光率，让别人更容易搜到你的文章，那就添加SEO吧，不过好像要下面介绍下加入百度SEO的步骤： 在百度中输入site:yourwebsite,好像要绑定了域名的网址才可以额，直接github.io的好像不行，百度站长平台。 填写要提交的网址： 选择站点的相关属性： 验证你的网站（这里有三种方法，你任选一种就好了，我试了后面两种，操作简单方便。我最后使用的是第三种添加一条解析）： CNAME验证方式如下，记录类型选CNAME，主机记录就填百度给的,记录值为zz.baidu.com。 接下来要让你的网站生成网站地图，及生产sitemap，将sitemap提交到百度，先安装地图生成插件：12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 然后查看是否在根目录的_config.xml配置文件下添加了你的url：重新部署后即可在public文件下看到sitemap.xml和baidusitemap.xml文件，在浏览器中输入你的网址/sitemap.xml即可看到所生成的地图文件，表示安装成功。 接着是提交你的sitemap到百度，点击链接提交进行提交。分为自动提交和手动提交。自动提交提供了3中方式，可以都使用，也可以只使用其中的一种：根据提示操作即可。建议采用自动提交额，手动提交会累死人 然后进行死链提交：提交完了等着就好了，可能要很久才生效。。。 添加谷歌SEO作为程序boy，google是少不了的，所以也把你的网站加到谷歌SEO吧，添加到谷歌的话很快就能生效的额，大概只要几分钟吧，添加起来也是比较简单滴。当然要先自备天梯。。。 敲黑板！首先得有个谷歌账号，自由发挥吧，然后到这里添加地址去添加你的网址。 也可以现在google总共输入如下内容，然后进入到添加网站的地址： 点击添加属性后即可添加你的博客地址。 添加完成之后进行网站验证，我使用的貌似是备用方法，比较便捷。 添加好之后稍等一会儿再Google中输入关键字，就可以看到效果啦 添加评论系统来必力评论系统真是个令我伤心的东西，我用的hueman主题也是集成了几种评论系统的，但是都是坑啊，disqus是国外的额。畅言是要备案的，友言的感觉不是很好看，之前很强大多说在6月1号关了，转战云更贴，结果宣布在8月1号正式停用。嗯！就是今天，八一建军节九十周年！此处比心~ 其实后面才知道有来必力这玩意儿的，第一眼看它还有点不顺眼，原因你懂的，后来发现用的人还挺多的，于是最后还是被它征服了 官网传送门，注册的时候会出现点韩语，不过莫慌，该看懂的还是看的懂额，嗯就酱。 注册好后到管理页面去： 在代码管理中获取安装代码：（此处针对的是hueman主题，其他的应该类似）获取安装代码后，在主题的comment下新建一个文件放入刚刚那段代码，再找到article文件，找到如下代码，若没有则直接在footer后面添加即可。livebe即为刚刚所创文件名称。1&lt;%- partial(&apos;comment/livebe&apos;) %&gt; 完成上面步骤之后可选择性进行一些相关配置，如下： 重新部署博客后即可看到效果： 添加百度统计百度统计也是个好东西，因为可以看到一些很详细的信息！ 百度统计传送门 在管理这一栏先把要统计的网站添加进来： 然后找到代码获取，进行代码安装： 代码安装好后重新部署，再回到百度统计中进行代码安装检查，安装正确即可。 差不多等个半小时吧，再进入到报告这一栏即可查看相关数据了。 文章阅读量统计leanCloud对于文章数量的统计，leanCloud是个好东西，官网传送门，leanCloud功能繁多，你可以好好的利用一番，这里主要讲文章阅读数量。 乖乖注册好账号之后去添加一个应用： 点击你的应用右上角的齿轮，进入到配置页面： 在存储这一栏中创建一个新的Class Name： 新的Class Name为Counter： 然后在设置页面的应用Key可查看到你的App ID及App Key： 在主题的配置文件下添加如下：12345//若主题已集成则只需要加此段leancloud_visitors: enable: true app_id: 你的id app_key: 你的key 在article中适当的位置添加如下（取决于你要将它显示在何处）：1阅读数量:&lt;span id=&quot;&lt;%= url_for(post.path) %&gt;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&lt;%- post.title %&gt;&quot;&gt;&lt;/span&gt;次 在footer的最后添加如下代码：12345678910111213141516171819202122232425262728293031323334353637383940&lt;script src=&quot;//cdn1.lncld.net/static/js/2.5.0/av-min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var APP_ID = &apos;你的app id&apos;; var APP_KEY = &apos;你的app key&apos;; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); // 显示次数 function showTime(Counter) &#123; var query = new AV.Query(&quot;Counter&quot;); if($(&quot;.leancloud_visitors&quot;).length &gt; 0)&#123; var url = $(&quot;.leancloud_visitors&quot;).attr(&apos;id&apos;).trim(); // where field query.equalTo(&quot;words&quot;, url); // count query.count().then(function (number) &#123; // There are number instances of MyClass where words equals url. $(document.getElementById(url)).text(number? number : &apos;--&apos;); &#125;, function (error) &#123; // error is an instance of AVError. &#125;); &#125; &#125; // 追加pv function addCount(Counter) &#123; var url = $(&quot;.leancloud_visitors&quot;).length &gt; 0 ? $(&quot;.leancloud_visitors&quot;).attr(&apos;id&apos;).trim() : &apos;icafebolger.com&apos;; var Counter = AV.Object.extend(&quot;Counter&quot;); var query = new Counter; query.save(&#123; words: url &#125;).then(function (object) &#123; &#125;) &#125; $(function () &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); addCount(Counter); showTime(Counter); &#125;);&lt;/script&gt; 重启之后即可看到效果。 引入站长统计不蒜子文章阅读量可以用leanCloud，那么整站统计用不蒜子还是比较方便的，只需要在footer中适当的位置添加如下代码不蒜子传送门，重新部署即可：12&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 不蒜子可自行DIY~ 小结 搞完这些之后你会发现满满的都是账号，/(ㄒoㄒ)/~~ 这些可自行选择用一些，不需要都用上额 终于要告一段落了，有的时候为了这个东东，也是很费时啊，不过弄完之后也是挺开心的，加油吧少年！","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"http://visugar.com/tags/hexo博客/"},{"name":"评论系统","slug":"评论系统","permalink":"http://visugar.com/tags/评论系统/"},{"name":"来必力","slug":"来必力","permalink":"http://visugar.com/tags/来必力/"},{"name":"文章统计","slug":"文章统计","permalink":"http://visugar.com/tags/文章统计/"}]},{"title":"定时器（setTimeout）的秘密","slug":"20170728setTimeout","date":"2017-07-28T14:32:46.000Z","updated":"2017-07-28T14:37:25.605Z","comments":true,"path":"2017/07/28/20170728setTimeout/","link":"","permalink":"http://visugar.com/2017/07/28/20170728setTimeout/","excerpt":"","text":"写在前面setTimeout()是大家再熟悉不过的定时器，但平时对定时器的了解甚少，于是想看看setTimeout()的原理机制。 setTimeout()基础setTimeout()函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。1var timeer = setTimeout(function|code,delay); 注：其中为code时需要以字符串形式传入，一般都是使用传入function的形式。 setTimeout(func,delay,arg1,arg2···) setTimeout()可传入多个参数，第三个参数起是作为回调函数的参数传入。1234function add(a,b)&#123; console.log(a+b);&#125;setTimeout(add,4000,20,30); //20和30作为add的参数传入 结果为50 HTML5规定setTimeout()的最短时间间隔是4ms，对于不处在当前窗口的页面，浏览器会将时间间隔扩大到1000ms，若笔记本电脑处于电池供电状态，chrome及IE9以上版本，会将时间间隔切换到系统定时器，约15.6ms。 setTimeout()中回调函数的指向setTimeout()回调函数调用的是某个对象的方法，则其中this指向的是setTimeout所处的环境而并非指向该对象环境。 可使用ES5中的bind()方法解决this指向，即将对象环境绑定到要执行的回调函数上即可。123456789101112131415161718192021var name = &apos;lily&apos;;function Person(name)&#123; this.name = name; this.printName = function()&#123; console.log(this.name); &#125;&#125;var person01 = new Person(&apos;jike&apos;); //此处的this.name为window下的name，所以是&apos;lily&apos;window.setTimeout(person01.printName,1000);//此处将printName绑定在person01上，所以this.name的值为&apos;jike&apos;window.setTimeout(person01.printName.bind(person01),2000);//将printName中的this.name与person01限定在同一个作用域中，所以结果是&apos;jike&apos;window.setTimeout(function()&#123;person01.printName();&#125;,3000);//借助ES6中的箭头函数也可以解决问题window.setTimeout(() =&gt; &#123;person01.printName&#125;,1000); setTimeout运行机制setTimeout()和setInterval()的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout()指定的代码，必须等到本次执行的所有代码都执行完，才会执行。 例如：123task1();setTimeout(otherTask,1000);task2(); 其中task1和task2为立即执行任务，otherTask被指定在1s后执行，此时otherTask被添加到任务队列的尾部，要等当前的脚本中Event Loop的任务队列全部执行完成后，才开始执行otherTask，但如果task1和task2很耗时，前面的任务超过1s还未结束，此时otherTask只能等task1和task2运行结束，才会执行otherTask。 setTimeout(func,0)的运用当延迟时间设为0时，即当前任务队列一结束就立即执行func。（换个角度说就是同步任务的任务队列结束后尽早执行。）12345task01();setTimeout(function()&#123; console.log(&apos;hello!&apos;); //在task01和task02结束后立即打印hello!&#125;,0)task02(); 0ms在实际上是达不到的，根据HTML5标准，setTimeout()推迟执行的时间最少是4ms，如果小于这个值，会被自动增加到4，同时也是为了防止多个setTimeout(func,0)语句连续执行，造成性能问题。 setTimeout(func,0)可以调整事件的发生顺序。 clearTimeout()setTimeout()和setInterval()函数，都返回一个表示计数器编号的整数值，将该整数传入clearTimeout()和clearInterval()函数，就可以取消对应的定时器。两种定时器用的同一个编号池。 setTimeout()和setInterval()函数返回的整数值都是连续的，因此可以利用循环来清除所有的定时器。 防抖动（debounce）该方法用于防止某个函数在短时间内被密集调用，具体来具体来说，debounce方法返回一个新版的该函数，这个新版函数调用后，只有在指定时间内没有新的调用，才会执行，否则就重新计时。 实际中不要设置太多个setTimeout()和setInterval(),它们耗费CPU，理想做法是将要延迟执行的代码都放在同一个函数里，然后支队这个函数使用setTimeout()和setInterval()。 setInterval()setInterval()使用原理机制与setTimeout()一样，区别就是setInterval()是每隔多少ms执行一次回调函数。也可以传入大于两个参数。 setInterval()指定的是“开始执行”之间的间隔，并不考虑每次任指定的是“开始执行”之间的间隔，并不考虑每次任，比如，setInterval()指定每100ms执行一次，每次执行需要5ms，那么第一次执行后95ms后，第二次执行就会开始。如果某次执行需要105ms，即超过了delay时间，则执行结束后下一次执行就会立即开始。 setInterval()的最短间隔是10ms，小于10ms的时间间隔会被调整到10ms setInterval()具有累积效应，如果某个操作特别耗时，超过了setInterval()的时间间隔，排在后面的操作就会被累积起来，然后在很短的时间内连续触发，这可能会造成性能问题。 资源参考 你所不知道的setTimeout 你所不知道的setInterval setTimeout-MDN","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"setTimeout","slug":"setTimeout","permalink":"http://visugar.com/tags/setTimeout/"},{"name":"定时器","slug":"定时器","permalink":"http://visugar.com/tags/定时器/"}]},{"title":"拖放API中的drag和drop实战","slug":"20170725DragAndDrop","date":"2017-07-25T11:35:17.000Z","updated":"2017-07-28T14:34:26.772Z","comments":true,"path":"2017/07/25/20170725DragAndDrop/","link":"","permalink":"http://visugar.com/2017/07/25/20170725DragAndDrop/","excerpt":"","text":"写在前面在HTML5之前，实现拖放功能需要借助mousedown/mousemove/mouseover/mouseout/mouseup等鼠标事件来完成，HTML5中拖放API的出现使很多事情变简单。下面是做笔记做笔记~ 源码地址 栗子预览1 栗子预览2 栗子预览3 拖放过程拖放：包括拖拽（drag）和释放（drop） 拖放中涉及两个元素，分别是：源对象和目标对象，如下图源对象是被拖拽的元素，目标对象是要释放到的接收元素。 拖放事件： 拖放事件流为拖放操作开始后触发的一系列事件，分为以下两类： 发生在源对象上的事件123dragstart:用户开始拖动页面中的某个元素时触发的事件drag: 源对象在拖拽过程中持续触发的事件dragend:拖动完成时触发的事件，一般用于清空拖动过程中的状态等。 发生在目标对象上的事件1234dragenter:源对象进入到目标对象时，会触发目标对象的ondragenter事件dragleave:源对象移除之前调用了dragenter的元素时，目标元素触发的事件dragover：源对象进入目标对象后持续触发的事件drop：用户释放鼠标时，drop会在目标对象上被调用 设置元素可拖动1dragable = &quot;true&quot; 传输和控–dataTransfer dataTransfer对象可用于每个拖放事件中。用于获取和设置实际放置的数据，主要属性及方法如下：1234567setData(format,data):在dragstart事件中调用此函数可以注册一个MIME类型格式的传输项。getData(format):可以获取指定类型的注册数据项。types：属性以数组形式返回所有当前注册的格式。items：返回所有项机器相关格式列表files：返回与放置相关的所有文件clearData():不带参则清空所有注册数据，带参则移除指定注册项…………等等 来点儿小栗子说小栗子前说下两点： 触发dragover事件时，需要使用preventDefault()方法阻止默认事件，drag事件才能正常触发 dataTransfer中的files属性用到了File API规范的子集，files存放了文件列表，files支持下列属性：1234name:带有扩展名的文件全名type：文件的MIME类型size：以字节为单位的文件大小lastModifiedDate：最后一次修改文件内容的时间戳 下面会用到的FileReader对象详细请移步：FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中File对象可以是来自用户在一个元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果. 1.简单的节点拖放可将任意节点拖放到其他元素上，并插入到目标元素的前面拖放前后： 主要代码：123456789101112/*目标对象上触发的dragove事件*/ drag.addEventListener(&apos;dragover&apos;, function (e) &#123; e.preventDefault(); //阻止默认动作 &#125;) /*源对象释放，目标对象上触发的事件*/ drag.addEventListener(&apos;drop&apos;, function (e) &#123; ele.classList.remove(&apos;draging&apos;); if (e.target.nodeName === &apos;LI&apos;) &#123; e.target.parentNode.insertBefore(ele, e.target); //将源对象元素插入到目标元素前面 &#125; &#125;) 2.节点清除可将龙猫丢进垃圾桶，即清除img元素节点丢龙猫前后：主要代码：1234567891011121314151617181920212223242526272829303132&lt;h3&gt;拖动龙猫到垃圾桶后从DOM树中删除子元素&lt;/h3&gt; &lt;img id=&quot;bin&quot; src=&quot;./img/default.png&quot;&gt; &lt;hr/&gt; &lt;img id=&quot;item1&quot; class=&quot;imgs&quot; src=&quot;./img/01.jpeg&quot;&gt; &lt;img id=&quot;item2&quot; class=&quot;imgs&quot; src=&quot;./img/02.jpg&quot;&gt; &lt;img id=&quot;item3&quot; class=&quot;imgs&quot; src=&quot;./img/03.jpeg&quot;&gt; &lt;script&gt; //为源对象添加事件监听 —— 记录拖动了哪一个源对象 var imgs = document.querySelectorAll(&apos;.imgs&apos;); var target = document.querySelector(&apos;#bin&apos;); for(var i=0; i&lt;imgs.length; i++)&#123; var pic = imgs[i]; pic.ondragstart = function(e)&#123; //开始拖动源对象 e.dataTransfer.setData(&apos;imgID&apos;,this.id);//保存被拖拽源的id &#125; &#125; //为目标对象添加事件监听 —— 删除拖动的源对象 target.ondragover= function(e)&#123; e.preventDefault(); //阻止默认行为 &#125; target.ondrop= function(e)&#123; //源对象松手释放在了目标对象中 //删除被拖动的源对象 var id = e.dataTransfer.getData(&apos;imgID&apos;); var p = document.getElementById(id); p.parentNode.removeChild(p); //从父元素中删除子节点 &#125; &lt;/script&gt; 3.将本地图片拖放到页面中指定区域 可将你的美图拖到网页中显示 爆照前后效果： 主要代码：1234567891011121314151617181920212223242526var content = document.querySelector(&apos;#content&apos;); document.addEventListener(&apos;dragover&apos;,function(e)&#123; e.preventDefault(); //阻止document的默认事件 &#125;); document.addEventListener(&apos;drop&apos;,function(e)&#123; e.preventDefault(); //阻止document的默认事件(阻止照片在新窗口中打开) &#125;); content.addEventListener(&apos;dragover&apos;,function(e)&#123; e.preventDefault(); &#125;) content.addEventListener(&apos;drop&apos;,function(e)&#123; var imgFs = e.dataTransfer.files[0]; //files存放了文件列表 //console.log(imgFs); var fs = new FileReader(); //创建一个FileReader对象 fs.readAsDataURL(imgFs); /*图片资源加载完成之后显示在content中*/ fs.onload = function()&#123; var img = new Image(); img.src = fs.result; content.appendChild(img); &#125; &#125;) 小结对今天学习的知识点做个记录，欢迎大佬们指正~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"拖放API","slug":"拖放API","permalink":"http://visugar.com/tags/拖放API/"},{"name":"drag","slug":"drag","permalink":"http://visugar.com/tags/drag/"},{"name":"drop","slug":"drop","permalink":"http://visugar.com/tags/drop/"}]},{"title":"JS中client/offset/scroll等的宽高解析","slug":"20170725ClienOffsetScroll","date":"2017-07-25T11:28:30.000Z","updated":"2017-07-27T12:51:19.236Z","comments":true,"path":"2017/07/25/20170725ClienOffsetScroll/","link":"","permalink":"http://visugar.com/2017/07/25/20170725ClienOffsetScroll/","excerpt":"","text":"window相关宽高属性1. window.outerHeight (窗口的外层的高度) / window.outerWidth (窗口的外层的宽度) window.outerHeight获取整个浏览器窗口的高度（单位：像素），包括侧边栏（如果存在）、窗口镶边（window chrome）和窗口调正边框。包含调试窗及浏览器边框 window.outerWidth表示整个浏览器窗口的宽度，包括侧边栏（如果存在）、窗口镶边（window chrome）和调正窗口大小的边框。包含调试窗及浏览器边框 参考链接：window.outerHeight -MDNwindow.outerWidth-MDN 2. window.innerHeight (浏览器窗口的视口的高度)和 window.innerWidth window.innerHeight浏览器窗口的视口（viewport）高度（以像素为单位），如果存在水平滚动条，则包括它。不包含调试窗及浏览器边框 window.innerWidth浏览器视口（viewport）宽度（单位：像素），如果存在垂直滚动条则包括它。不包含调试窗及浏览器边框 参考链接：window.innerHeight - MDNwindow.innerWidth - MDN 3. window.screen.width和window.screen.height注：在获取值时可不加window.前缀 window.screen.width声明了显示当前浏览器的屏幕的宽度，以像素计 window.screen.height声明了显示当前浏览器的屏幕的高度，以像素计 参考链接：window.screen - MDNwindow.screen - MDN 4. window.screen.availHeight和window.screen.availWidth window.screen.availHeight声明了显示浏览器的屏幕的可用高度，以像素计。除去我们底部任务栏外的屏幕高度 window.screen.availWidth声明了显示浏览器的屏幕的可用宽度，以像素计 参考链接：window.screen - MDNwindow.screen - MDN 5. window.screenTop和window.screenLeft 功能： 返回窗口的左上角在屏幕上的x坐标。该属性为只读属性。语法： window.screenLeft。注：在Firefox等浏览器中使用的是screenX属性。 返回窗口的左上角在屏幕上的y坐标。该属性为只读属性。 语法： window.screenTop。注：在Firefox等浏览器中使用的是screenY属性。 参考链接：window.screenTopwindow.screenLeft document下面的相关属性（offset/client/scroll）与client相关属性6. document.body.clientWidth或element.clientWidth 表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有的话）、边框和外边距。 该属性值会被四舍五入为一个整数。如果你需要一个小数值，可使用 element.getBoundingClientRect()。 语法：var intElemClientWidth = element.clientWidth; 参考链接：Element.clientWidth - MDN 7. document.body.clientHeight或element.clientHeight返回元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。 参考链接：element.clientHeight - MDN 8. document.body.clientLeft或element.clientLeft表示一个元素的左边框的宽度，以像素表示。如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。 参考链接：Element.clientLeft - MDN 9. document.body.clientTop或element.clientTop一个元素顶部边框的宽度（以像素表示）。不包括顶部外边距或内边距。 参考链接：Element.clientTop 与offset相关属性这一对属性指的是元素的border+padding+content的宽度和高度 10. document.body.offsetWidth或element.offsetWidthborder/padding/width三者的总宽度 参考链接：HTMLElement.offsetWidth 11. document.body.offsetHeight或element.offsetHeightborder/padding/width三者的总高度，且是一个整数。 参考链接：HTMLElement.offsetHeight 12. HTMLElement.offsetLeft和HTMLElement.offsetTop这两个属性是基于offsetParent的 如果当前元素的父级元素没有进行CSS定位（position为absolute或relative）,offsetParent为body. 假如当前元素的父级元素中有CSS定位，offsetParent取最近的那个父级元素。 offsetLeft返回当前元素左上角相对于 HTMLElement.offsetParent 节点的左边界偏移的像素值。 offsetTop返回当前元素相对于其 offsetParent 元素的顶部的距离。 在IE6/7中：1offsetLeft=(offsetParent的padding-left)+(当前元素的margin-left) 在IE8/9/10及Chrome中：1offsetLeft=(offsetParent的margin-left)+(offsetParent的border宽度)+(offsetParent的padding-left)+(当前元素的margin-left) 在FireFox中：1offsetLeft=(offsetParent的margin-left)+(当前元素的margin-left)+(offsetParent的padding-left) 参考链接：HTMLElement.offsetLeftHTMLElement.offsetTop 与scroll相关属性13. document.body.scrollWidth及document.body.scrollHeightbody与普通element不一样 给定body宽高 &lt; 浏览器窗口时：12scrollWidth = 浏览器窗口宽度scrollHeight = 浏览器窗口高度 给定body宽高大于浏览器窗口，且内容小于给定body宽高时：12scrollWidth = 给定的宽度 + body所有padding + body所有margin + body所有borderscrollHeight = 给定的高度 + body所有padding + body所有margin + body所有border 给定body宽高大于浏览器窗口，且内容大于给定窗口时：12scrollWidth = 内容的宽度 + body所有padding + body所有margin + body所有borderscrollHeight = 内容的高度 + body所有padding + body所有margin + body所有border 参考链接：Element.scrollWidth 14. element.scrollWidth和element.scrollHeight当无滚动条时：12scrollWidth = clientWidth = 元素宽度 + padding和scrollHeight = clientHeight = 元素高度 + padding和 当有滚动条时：12scrollWidth = 实际内容的宽度 + padding和scrollHeight = 实际内容的高度 + padding和 15. document.body.scrollTop及document.body.scrollLeft 这对属性是可读写（可被重新赋值） 的 指的是当元素其中的内容超出其宽高的时候，元素被卷起来的高和宽度。 对于element元素同样适用 16. window.scrollY及window.scrollXwindow.scrollY 文档从顶部开始滚动过的像素值 / window.scrollX 文档从左侧开始滚动的像素值。 event中的五种坐标1、clientX及clientY：相对于浏览器（可视区左上角0,0）的坐标 2、screenX和screenY：相对于设备屏幕左上角（0,0）的坐标 3、offsetX和offsetY：相对于事件源左上角（0,0）的坐标 4、pageX和pageY：相对于整个网页左上角（0,0）的坐标 参考来源： 视频课程：JS/jQuery宽高的理解和应用 博客：JavaScript中的各种宽高属性","categories":[{"name":"划重点","slug":"划重点","permalink":"http://visugar.com/categories/划重点/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"width/height","slug":"width-height","permalink":"http://visugar.com/tags/width-height/"},{"name":"offset/client/scroll","slug":"offset-client-scroll","permalink":"http://visugar.com/tags/offset-client-scroll/"}]},{"title":"css实现鼠标悬浮字体流光背景模糊效果","slug":"20170626FontLightBlur","date":"2017-06-26T10:36:31.000Z","updated":"2017-06-26T10:39:10.235Z","comments":true,"path":"2017/06/26/20170626FontLightBlur/","link":"","permalink":"http://visugar.com/2017/06/26/20170626FontLightBlur/","excerpt":"","text":"写在前面有的时候感觉写点小玩意儿挺开心的，还能实践很多的小知识点，所以这次学着写了个有趣的鼠标悬浮模糊效果，只使用了css额。 效果图 源码地址→传送门 预览地址→传送门 小知识点filter: blur(npx); 这个过滤器用来将图片模糊，但是兼容性不太好，n代表模糊度，值越大越模糊。 background-clip: text; background-clip是用于背景图片的裁剪，决定背景从哪里开始显示。当设置为text时，即可将背景设置在字体上。 text-fill-color 这个属性为字体颜色填充，在这里设置成transparent,然后在自己填充一个颜色渐变的字体颜色。 linear-gradient 线性渐变，这里为文字添加一个渐变色，为了实现流光渐变的效果，需要将背景宽度设置为200%，且linear-gradient的0%和100%颜色一样，便于前后衔接上，具体如下：12background-image: -webkit-linear-gradient(left, red, yellow 25%, red 50%, yellow 75%, red 100%);background-size: 200% 100%; 在设置好背景色之后为字体添加动画，使文字产生流光效果。 鼠标悬浮显示和隐藏现将元素的透明度设为0，当鼠标悬浮时执行渐变透明度变为1。 边框向两边伸展的效果 在实际中我们只能设置边框的宽度，而不能改变边框的长度，所以此处不能直接用border的属性。而是通过追加2个元素，并改变其大小来实现本元素的边框向两边伸展的效果。分别设置这两个元素的上下边框及左右边框。原理图(实现为所设边框，虚线为不设置边宽)： 追加元素的实现追加元素宽或高为0，当鼠标移动到box上时，宽或高渐变到100%，即可。1234567891011121314151617#content:before &#123; content: &quot; &quot;; position: absolute; left: 50%; top: 0; width: 0; height: 100%; border: 3px solid #fff; border-left: none; border-right: none; transition: all 0.8s; box-sizing: border-box; &#125;#box:hover #content:before &#123; width: 100%; left: 0; &#125; 左和右边框同理实现。 小结以前感觉好多属性用不上，这下用上了好多个，以后继续写写写~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"CSS3","slug":"CSS3","permalink":"http://visugar.com/tags/CSS3/"}]},{"title":"原生JS实现省市区（县）三级联动选择","slug":"20170609ThreeLevel","date":"2017-06-09T12:28:08.000Z","updated":"2017-07-27T12:31:39.312Z","comments":true,"path":"2017/06/09/20170609ThreeLevel/","link":"","permalink":"http://visugar.com/2017/06/09/20170609ThreeLevel/","excerpt":"","text":"写在前面前段时间写一个关于天气的东西，里面的省市区（县）城市选择让我很头疼，在网上搜索出来大都是借助插件或者第三方库，感觉这样做代码会很重，所以索性就把几种城市选择的方式实现一遍，以备日后的不时之需。这三种方法都是针对pc端的，并且都是使用原生js实现的，连jq都没使用，于是代码有点繁琐额（尴尬）。。。。不过还是让我把原理讲完吧。 源代码地址→传送门 预览地址→传送门 方法一：下拉选择框实现省市区（县）三级联动用下拉框实现省市区三级联动是很常见的一种方式，也很方便。这里需要先了解下select的相关属性及其对象属性，请参考此文 先看下最终实现效果图： 思路介绍： 页面加载时，动态获取省份列表并放到下拉菜单的下拉项中：1234567891011 /*自动加载省份列表*/(function showProv() &#123; btn.disabled = true; var len = provice.length; for (var i = 0; i &lt; len; i++) &#123; var provOpt = document.createElement(&apos;option&apos;); provOpt.innerText = provice[i][&apos;name&apos;]; provOpt.value = i; prov.appendChild(provOpt); &#125;&#125;)(); 当点击省份列表中的某一项，此时触发省份下拉框的onchange事件，在onchange事件中根据前面所选的省份来显示对应城市。这里用到一个select的selectedIndex属性，从而获取刚刚点击的是哪个省份（生成省份列表时添加了value属性值）：1var val = obj.options[obj.selectedIndex].value; //这里得到的是所选择省份在所有下拉项中为第几项 当点击城市列表中的某一项时，原理同上（此处不赘述）选择城市时存在两种情况，如何城市选项下不存在县区，则直接将所选省市显示在输入框，否则依照上诉原理显示县区123456&lt;!--方法是判断县区的length是否为0--&gt;var countryLen = provice[current.prov][&quot;city&quot;][val].districtAndCounty.length; if(countryLen == 0)&#123; addrShow.value = provice[current.prov].name + &apos;-&apos; + provice[current.prov][&quot;city&quot;][current.city].name; return; &#125; 最后点击县区后再按确定，则可将所选地点显示在输入框中。 注意: 在未选中具体县区时，按钮为不可点状态 具体的实现主要根据城市数据来进行更细的处理。 说明： 这里使用的省市区数据来源于网络，不能保证真实性及完整性，仅供案例使用 此处使用的数据类型为js数组,格式参考如下（完整版）： 123456789101112131415161718192021222324252627282930var provice = [ &#123; name: &quot;北京市&quot;, city: [ &#123; name: &quot;北京市&quot;, districtAndCounty: [&quot;东城区&quot;, &quot;西城区&quot;, &quot;崇文区&quot;, &quot;宣武区&quot;, &quot;朝阳区&quot;, &quot;丰台区&quot;, &quot;石景山区&quot;, &quot;海淀区&quot;, &quot;门头沟区&quot;, &quot;房山区&quot;, &quot;通州区&quot;, &quot;顺义区&quot;, &quot;昌平区&quot;, &quot;大兴区&quot;, &quot;怀柔区&quot;, &quot;平谷区&quot;, &quot;密云县&quot;, &quot;延庆县&quot;, &quot;延庆镇&quot;] &#125; ] &#125;, ...... &#123; name: &quot;河北省&quot;, city: [ &#123; name: &quot;石家庄市&quot;, districtAndCounty: [&quot;长安区&quot;, &quot;桥东区&quot;, &quot;桥西区&quot;, &quot;新华区&quot;, &quot;裕华区&quot;, &quot;井陉矿区&quot;, &quot;辛集市&quot;, &quot;藁城市&quot;, &quot;晋州市&quot;, &quot;新乐市&quot;, &quot;鹿泉市&quot;, &quot;井陉县&quot;, &quot;微水镇&quot;, &quot;正定县&quot;, &quot;正定镇&quot;, &quot;栾城县&quot;, &quot;栾城镇&quot;, &quot;行唐县&quot;, &quot;龙州镇&quot;, &quot;灵寿县&quot;, &quot;灵寿镇&quot;, &quot;高邑县&quot;, &quot;高邑镇&quot;, &quot;深泽县&quot;, &quot;深泽镇&quot;, &quot;赞皇县&quot;, &quot;赞皇镇&quot;, &quot;无极县&quot;, &quot;无极镇&quot;, &quot;平山县&quot;, &quot;平山镇&quot;, &quot;元氏县&quot;, &quot;槐阳镇&quot;, &quot;赵县&quot;, &quot;赵州镇&quot;] &#125;, ....... &#123; name: &quot;邯郸市&quot;, districtAndCounty: [&quot;丛台区&quot;, &quot;邯山区&quot;, &quot;复兴区&quot;, &quot;峰峰矿区&quot;, &quot;武安市&quot;, &quot;邯郸县&quot;, &quot;南堡乡东小屯村&quot;, &quot;临漳县&quot;, &quot;临漳镇&quot;, &quot;成安县&quot;, &quot;成安镇&quot;, &quot;大名县&quot;, &quot;大名镇&quot;, &quot;涉县&quot;, &quot;涉城镇&quot;, &quot;磁县&quot;, &quot;磁州镇&quot;, &quot;肥乡县&quot;, &quot;肥乡镇&quot;, &quot;永年县&quot;, &quot;临洺关镇&quot;, &quot;邱县&quot;, &quot;新马头镇&quot;, &quot;鸡泽县&quot;, &quot;鸡泽镇&quot;, &quot;广平县&quot;, &quot;广平镇&quot;, &quot;馆陶县&quot;, &quot;馆陶镇&quot;, &quot;魏县&quot;, &quot;魏城镇&quot;, &quot;曲周县&quot;, &quot;曲周镇&quot;] &#125; ] &#125;] 方法二：按级选中省市县/区 这种方式比上面的下拉框更好看点，操作也更方便点，不过大概的逻辑有点类似。所用省市区数据跟上面的一致。 先看看这种方式的效果图： 在页面加载时同样先显示出所有的省份列表（方法类似） 点击具体省份时，将省份列表替换成对应的城市列表，点击具体城市时显示对应县区，实现如下：1234567891011121314151617181920212223242526addrWrap.onclick = function (e) &#123; //将点击事件委托给列表的父元素 var n; var e = e || window.event; var target = e.target || e.srcElement; if (target &amp;&amp; target.nodeName == &apos;LI&apos;) &#123; /*先判断当前显示区域显示的是省市区的那部分*/ for (var z = 0; z &lt; 3; z++) &#123; if (titleWrap[z].className == &apos;titleSel&apos;) n = z; &#125; /*显示的处理函数*/ switch (n) &#123; case 0: showCity2(target.index); //点击的是省份中列表的某一项，接下来则显示城市列表 break; case 1: showCountry2(target.index); //点击的是城市列表中的某一项，接下来则显示县区列表 break; case 2: selectCountry(target.index); //点击具体的某个县区，则将该县区选择 break; default: showProv2(); &#125; &#125;&#125;; 5.上面点击的每一步中将选中项的索引及值保存在一个对象中，以便最后点击确定按钮将选择的省市区显示在输入框中。6.当选择的城市不存在县区时处理跟第一种方式一致。7.当点击分类时，显示对应的内容，同时将保存的对象的值进行处理：12345678//将事件委托给父元素,根据点击的分类进行处理（html的设置好li的value值）if (target.value == &apos;0&apos;) &#123; showProv2();&#125; else if (target.value == &apos;1&apos;) &#123; showCity2(current2.prov);&#125; else &#123; showCountry2(current2.city);&#125; 8.OK 方法三：按字母顺序选中城市 直接按字母的顺序选中城市这种方式比前两种更简单粗暴也较为简单，代码量也较少。 先看看这种方式的效果图： 页面加载时先显示热门城市 点击不同字母集，显示对应的城市列表12345678910switch (index) &#123; case 0: //0为热门项 showHotCity(); break; case 6: //6为最后一栏，字母集个数为2 showCitys(index, 2); break; default: //其余索引，字母集个数都为4 showCitys(index, 4); &#125; 12345678function showCitys(index, m) &#123; //通过传入的参数截取城市数据的一部分为当前要显示的城市列表 var currentAll = cityAll.slice(4 * index - 3, 4 * index + m - 3); ..... //将动态生成的列表项放到显示区域&#125; 5.点击具体某一个城市时，将其显示在输入框中。6.这种方式的城市数据跟前两种不同，来源于网上，不能保证真实性及完整性，仅供案例使用，数据格式如下（完整版）： 1234567891011121314151617var cityAll = [ &#123; name: &quot;hot&quot;, citys: [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;, &quot;杭州&quot;, &quot;南京&quot;, &quot;成都&quot;, &quot;重庆&quot;, &quot;武汉&quot;, &quot;长沙&quot;, &quot;昆明&quot;] &#125;, &#123; name: &quot;A&quot;, citys: [&quot;阿坝&quot;, &quot;阿拉善&quot;, &quot;阿里&quot;, &quot;安康&quot;, &quot;安庆&quot;, &quot;鞍山&quot;, &quot;安顺&quot;, &quot;安阳&quot;, &quot;澳门&quot;] &#125;, ...... &#123; name: &quot;Z&quot;, citys: [&quot;杂多县&quot;, &quot;赞皇县&quot;, &quot;枣强县&quot;, &quot;枣阳市&quot;, &quot;枣庄&quot;,.......,资阳&quot;]&#125; 7.完美~ 小结 详细代码看上面给出了链接，有注释的额（firefox和chrome可正常显示）~ 这几种实现方式为一己之见，欢迎大佬们指点，如有更好的可以告诉我，我来完善完善~ 有人能告诉我怎么做gif图么？","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"select","slug":"select","permalink":"http://visugar.com/tags/select/"},{"name":"省市区三级联动","slug":"省市区三级联动","permalink":"http://visugar.com/tags/省市区三级联动/"},{"name":"JS","slug":"JS","permalink":"http://visugar.com/tags/JS/"}]},{"title":"select表单元素详解及下拉列表模拟实现","slug":"20170608SelectList","date":"2017-06-08T11:45:10.000Z","updated":"2017-07-27T12:26:42.938Z","comments":true,"path":"2017/06/08/20170608SelectList/","link":"","permalink":"http://visugar.com/2017/06/08/20170608SelectList/","excerpt":"","text":"写在前面select 是HTML表单元素中很常用的一个，其中很重要的几个属性常被忽略，但这几个属性却能帮助我们完成很多的功能，当然，select下拉列表默认样式很不友好，所以更多的时候可以自己模拟实现一个同样功能的下拉菜单。下文先介绍select标签的一些属性及使用，后面再模拟一个相同效果的下拉菜单。 介绍之前先看下demo预览图： 1.firefox下select的默认样式： 2.chrome下select的默认样式： 3.firefox下自定义select下拉列表的icon效果： 4.chrome下自定义select下拉列表的icon效果： 5.原生js模拟select下拉列表的实现效果(chrome及firefox效果一致)： 源代码地址→传送门 预览地址→传送门 1. select表单元素及相关属性（我只是大自然的搬运工）提示select 元素是一种表单控件，可用于在表单中接受用户输入支持的全局属性 仅挑几个属性 autofocus(其值为autofocus): 规定在页面加载后文本区域自动获得焦点。 disabled(值为disabled): 规定禁用该下拉列表。 form(值为form_id): 规定文本区域所属的一个或多个表单。 multiple(值为multiple): 规定可选择多个选项。 支持的事件属性 挑一个最常用到的额 onchange：当select改变选择时调用的事件句柄。(可以实现三级联动的效果) selected对象的属性及方法 挑几个重要的额 options[]：返回包含下拉列表中的所有选项的一个数组。 length：返回下拉列表中的选项数目。 selectIndex：设置或返回下拉列表中被选项目的索引号。 add(): 向下拉列表添加一个选项。 remove(): 从下拉列表中删除一个选项。 option标签 option元素定义下拉列表中的一个选项（一个条目）。 disabled(值为disabled)：规定此选项应在首次加载时被禁用。 label(值为text)：定义当使用 时所使用的标注。 selected)(值为selected)：规定选项（在首次显示在列表中时）表现为选中状态。 value(text): 定义送往服务器的选项值。 option对象的属性 几个比较重要的额 defaultSelected：返回 selected 属性的默认值。 disabled:设置或返回选项是否应被禁用。 index：返回下拉列表中某个选项的索引位置。 selected：设置或返回 selected 属性的值。 注意： select本身的样式可用css设置，但对option设置的样式在chrome中不起作用，在Firefox可行 w3c官网的详细解释 → 传送门 2. HTML标签自定义属性（纯属题外话）HTML5 data-*自定义属性：添加data-前缀使属性变成自定义属性，最大的好处是我们可以把所有自定义属性在dataset对象中统一管理。 1234567&lt;div id=&quot;student&quot; data-weight=&quot;98&quot;&gt;点击显示&lt;/div&gt;var student = document.getElementById(&quot;student&quot;);student.dataset.cm = &apos;168&apos;; //设置自定义属性var stuWeight = studdent.dataset.weight; //获取自定义属性值student.dataset.birthDate = &apos;19980612&apos;; //连字符的自定义属性 (例如设置data-birth-date) 3. 自定义下拉列表的图标select默认样式中的下拉按钮不是很好看，我们可以自己用替张图片替换掉。（效果看文章上面的链接，请忽略我的丑丑的图标额） 1.对select自定义图标时需要设置apperance属性为none(隐藏原有小三角)，并做兼容 2.加上将要替换的自定义图标即可 12345select&#123; -webkit-appearance: none; /*隐藏默认样式中的小三角*/ -moz-appearance: none; background: url(&apos;http://opif0c56u.bkt.clouddn.com/select.gif&apos;) no-repeat scroll right 8px center;&#125; 3.可对option添加背景色 4.在firefox中可使用伪元素:before对option添加序号（此处插播一个css添加序号的方法）1234567select&#123; counter-reset: item; //类似于声明计数变量（声明在父元素中）&#125;select option:before &#123; counter-increment: item; //要使用的计数名 content: counter(item) &quot; . &quot;; //追加前置序号,chrome对option的设置中不起作用&#125; 4. js模拟select下拉菜单(重头戏)许多时候会觉得select表单特别的不好用，不能自己添加很多的样式，小伙伴们还是自己模拟一个吧！ 1.html代码结构： 12345678910&lt;div id=&quot;sel-wrap&quot;&gt; &lt;div id=&quot;sel-show&quot;&gt;=请选择=&lt;/div&gt; &lt;ul id=&quot;sel-option&quot;&gt; &lt;li class=&quot;item&quot;&gt;早上吃包子&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;中午吃米饭&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;晚上吃面条&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;宵夜吃烧烤&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;睡前喝牛奶&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.下拉按钮的图标跟上面自定义的方式一致（这里不再说了）。 3.hover到li上时，利用伪元素:before追加一个对勾。 123#sel-option li:hover:before &#123; content: &apos;\\2714&apos; &apos; &apos;; //此处为对勾+空格 &#125; 4.下面说下实现原理： 下拉菜单的选项为ul中的内容，需要先隐藏起来，且显示的时候是浮在其他内容的上面，此处需要使用position来实现。（即脱离文档流）123456#sel-wrap&#123; position: relative; //设置父元素&#125;#sel-option&#123; position: absolute; //设置下拉列项的包裹层&#125; 点击下拉框时显示下拉列表项 点击列表项时将选中值传递给下拉框并显示，同时下拉项收起（此处的点击事件绑定在父元素中） 当下拉项显示并未选中任何下拉项时，点击下拉框收起下拉项 当下拉项显示并未选中任何下拉项时，点击下拉项以外的任意位置，收起下拉框 最终实现（样式什么的都可以随便改）： 小结 小花作为菜鸟第一次自己模拟下拉列表的实现，有可能存在代码欠缺，但是为了方便以后使用的时候查询，所以就记录下 欢迎大佬们指点","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"css3","slug":"css3","permalink":"http://visugar.com/tags/css3/"},{"name":"select","slug":"select","permalink":"http://visugar.com/tags/select/"}]},{"title":"预览github项目的html文件新方法","slug":"20170519PreviewHtml","date":"2017-05-19T04:32:01.000Z","updated":"2017-07-27T12:21:35.055Z","comments":true,"path":"2017/05/19/20170519PreviewHtml/","link":"","permalink":"http://visugar.com/2017/05/19/20170519PreviewHtml/","excerpt":"","text":"写在前面关于如何在线预览github中的html文件，其实这是一个很多人知道的东西，但是查资料的时候呢总是找不到正确的答案，并且一开始我也是踩了坑的。 踩坑经历搜出来的结果大概就两种： 第一种是在你打开的源码地址的url地址基础上加http://htmlpreview.github.io/?或者http://htmlpreview.github.com/?(注：填这个还是会转到前面那个前缀去的)前缀。 第二种就是在你的项目branch上添加一个gh-pages分支，然后将你的项目复制一份到这个分支上，然后再进入settings的github pages进行设置就OK了。 总结下上面两种，添加前缀的方式确实比较简单，但是东西多了就会加载很慢，甚至不能正确的显示css样式，对于显示js的效果就更不使用了。所以，赶快放弃吧！创建分支的方式确实是很麻烦额，之前就是感觉麻烦的不得了所以没用这种方式，接下来要介绍的是创建分支的升级版，看下文~ 取经啦一度感觉小花说话很麻烦，请不要见怪！！！ 第一步就是找到你要展示的repo中的Settings 找到github pages那一栏,在Source中选择master branch,然后save 放大你的眼睛找到你自己的这串地址 然后就可以愉快的预览了 完美~ 小结刚开始自己踩坑发现不对劲但又苦于找不到解决方法，后来偶然有个同学告诉我这样纸，所以，我就只是枚小小的搬运工而已~ 给看完本文的孩纸们一个爱的么么哒","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"github","slug":"github","permalink":"http://visugar.com/tags/github/"},{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"}]},{"title":"CSS3饼状loading效果","slug":"20170517RoundLoading","date":"2017-05-17T00:36:33.000Z","updated":"2017-05-18T11:45:40.519Z","comments":true,"path":"2017/05/17/20170517RoundLoading/","link":"","permalink":"http://visugar.com/2017/05/17/20170517RoundLoading/","excerpt":"","text":"写在前面（附录有源码及效果） 之前碰到一个小练习，就是用纯CSS3来写饼状的loading效果，之前着实没有写过这玩意儿，小花完全没头绪，然后参考了张鑫旭老师的CSS3实现鸡蛋饼饼状图loading等待转转转，还有些别的东西，用一种看起来有一点类似但是好像又不一样的方式完成了同样的效果，题目要求的大概就是这个样子： 开始琢磨了一下，睡一觉起来画了个图，理顺了一下，不过感觉此图有点难意会啊啊啊啊啊，没关系，小花会在后文一点一点解释哒~(红跟粉代表颜色，斜杠后面是z-index的值) 原理这个东西分为两部分：外圈和内圆。颜色这东西都自定义啦，不过我画的的圈圈好像有点太大，然后动画时间是随便设的，反正转起来看着感觉有点怪怪的额 先上html结构12345678910111213&lt;div class=&quot;con-wrap&quot;&gt; &lt;!--外圈--&gt; &lt;div class=&quot;out-round&quot;&gt;&lt;/div&gt; &lt;!--内圆，里面有半圆四个--&gt; &lt;div class=&quot;in-round&quot;&gt; &lt;div class=&quot;lt-round&quot;&gt;&lt;/div&gt; &lt;div class=&quot;lt-mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;rt-round&quot;&gt;&lt;/div&gt; &lt;div class=&quot;rt-mask&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 外圈和内圆是通过position定位重合在一起，实质上外圈转完2圈，内圆的红色和粉色才各转完1圈（内圆的全程包括红色从1到0、粉色从1到0），所以内圆的动画时间应该是外圈的两倍！！！ 外圈 外圈很简单，设置border-radius:50%即可画出一个圆，然后设置三条边框为红色，另外一条为透明，即画出了四分之三个圆边框（即外圆）。123456789.out-round &#123; width: 100px; height: 100px; border-radius: 50%; margin: 150px auto; border: 3px solid #FF298C; border-left: 3px solid transparent; animation: outRound 1s linear infinite running; &#125; 接下来是外圈的动画，为其设置的动画就是旋转一圈，infinite表示无限次12345678@keyframes outRound &#123; 0% &#123; transform: rotate(120deg) &#125; 100% &#123; transform: rotate(-240deg) &#125; &#125; 其中rotate(120deg)为旋转起始位置，可根据实际情况调整。 至此外圈就完成了，比较麻烦的是下面的内圆，不过根据图示应该是可以想象的。 内圆 此处有四个半圆，左边两个，右边两个（round为红色，mask为粉色），动画主要通过改变两个红色半圆的z-index值来控制各个半圆显示的优先顺序。内圆的css实现部分为：1234567891011121314151617/*左边两个半圆*/ .lt-round, .lt-mask &#123; position: absolute; width: 35px; height: 70px; border-radius: 35px 0 0 35px; transform-origin: right center; &#125; /*右边两个半圆*/ .rt-round, .rt-mask &#123; position: absolute; left: 50%; width: 35px; height: 70px; border-radius: 0 35px 35px 0; &#125; 下面过程描述内圆的动画全程（其中右边的粉色全程不需要动，右边红色部分只需要改变z-index的值来改变显示的优先级，从而实现显示和隐藏的效果来配合补充左半边的圆。）： 1.初始设置： 12345红左 z-index：3粉1 z-index：2红右 z-index：1粉2 z-index：0 模型图： 视觉效果图(忽略中间的白线)： 2.左边红色旋转完180度时（逆时针旋转所以是360→180→0） 模型图： 视觉效果图： 3.左边红色转完到0度时（此时左右两边的红色半圆被粉色覆盖） 模型图： 视觉效果图： 4.粉色半圆重复之前红色半圆的动画（即左边粉色360→180→0） 模型图： 视觉效果图： 5.当左边粉色旋转到0度时，全部半圆回到了最初始的状态，整个动画即完成（在相同时间下外圈完成了2次的动画）。 模型图： 视觉效果图： 动画代码部分1.前半程为左边红色旋转一周，后半程为粉色旋转一周。动画实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*左边红色完成第一圈的旋转*/@keyframes ltRound &#123; 0% &#123; transform: rotate(360deg); &#125; 24.9% &#123; z-index: 3; &#125; 25% &#123; z-index: 1; transform: rotate(180deg); &#125; 50% &#123; transform: rotate(0deg); &#125; 74.9% &#123; z-index: 1; &#125; 75%, 100% &#123; z-index: 3; &#125; &#125;/*右边红色圆通过z-index来控制显示和隐藏，从而达到在适当时间配上左半圆的效果*/@keyframes rtRound &#123; 0%, 24.9% &#123; z-index: 1; &#125; 25% &#123; z-index: -3; &#125; 74.9% &#123; z-index: -3; &#125; 75%, 100% &#123; z-index: 1; &#125; &#125; /*左边粉色完成第二圈的旋转*/@keyframes ltMask &#123; 0%, 25%, 50% &#123; transform: rotate(360deg); &#125; 75% &#123; transform: rotate(180deg); &#125; 100% &#123; transform: rotate(0deg); &#125; &#125; 2.在全部代码未完成时，可以将动画时间设大一点，这样便于观察，搞完了再设回去就OK了。 3.由于动画是匀速变化的，但是z-index的值不能匀速变化，所以只能在某个很短时间内去改变z-index的值。这样才能达到效果（突然感觉这种实现好像也不是很好） 小结 没做兼容，在chrome中无异常，别的我就不太知道了 只是用来练习练习，实际上不一定会用到，但是里面几个知识点还是hei有用滴 小花是小白，对很多东西都还没整明白，欢迎大佬们指点指点~ 这几个图画的我心好累，sei能给小花推荐个好用点的额 源代码源码地址 预览地址","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"css3","slug":"css3","permalink":"http://visugar.com/tags/css3/"},{"name":"z-index","slug":"z-index","permalink":"http://visugar.com/tags/z-index/"}]},{"title":"RegExp（正则表达式）常用要点小结","slug":"20170511RegRxp","date":"2017-05-11T08:17:05.000Z","updated":"2017-05-18T11:42:05.968Z","comments":true,"path":"2017/05/11/20170511RegRxp/","link":"","permalink":"http://visugar.com/2017/05/11/20170511RegRxp/","excerpt":"","text":"正文正则表达式用到的地方很多，但是每次很久不用就全忘光了，每次都要重新看一遍文档，为了节省时间，把它的一些基本要点画总结在一张图片中，这样方便以后查看。 PS：细节的东西还是需要看详细点的文档。 原图传送门","categories":[{"name":"划重点","slug":"划重点","permalink":"http://visugar.com/categories/划重点/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"文档","slug":"文档","permalink":"http://visugar.com/tags/文档/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://visugar.com/tags/正则表达式/"}]},{"title":"中文技术文档规范-改自阮一峰老师","slug":"20170510DocRule","date":"2017-05-10T01:08:30.000Z","updated":"2017-05-18T11:41:47.441Z","comments":true,"path":"2017/05/10/20170510DocRule/","link":"","permalink":"http://visugar.com/2017/05/10/20170510DocRule/","excerpt":"","text":"正文以前从来去想一篇技术文章要怎么架构，总是随自己想到什么写什么，然后看到了阮一峰老师的总结，就把它改成了思维导图，以便记忆查询。 原文地址：https://github.com/ruanyf/document-style-guide 原图传送门","categories":[{"name":"划重点","slug":"划重点","permalink":"http://visugar.com/categories/划重点/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"写作规范","slug":"写作规范","permalink":"http://visugar.com/tags/写作规范/"},{"name":"文档","slug":"文档","permalink":"http://visugar.com/tags/文档/"}]},{"title":"菜鸟张小花之多种前端布局实现","slug":"20170506Layout","date":"2017-05-06T08:09:57.000Z","updated":"2017-07-27T12:18:19.763Z","comments":true,"path":"2017/05/06/20170506Layout/","link":"","permalink":"http://visugar.com/2017/05/06/20170506Layout/","excerpt":"写在前面 由于知识有限，有的内容可能有点小错误什么的，仅供参考参考，欢迎大佬们指正","text":"写在前面 由于知识有限，有的内容可能有点小错误什么的，仅供参考参考，欢迎大佬们指正，小花在这里谢过~ 小贴士（to freshman）：给每个块都加上颜色，更好辨识。 关于代码：这里给出的都是css部分，html部分用最常规的结构就好啦 1. 水平居中方法一：margin:0 auto; （最常用的居中布局方式） 方法二：text-align和inline-block的结合（设置父元素的text-align为center）。 这种方式最好应用于图片、按钮、文字之类的居中模式，否则就需要借助inline-block来进行居中布局。 方法三：position绝对定位来实现居中布局。 适用于块级元素不给出宽高的情况下(需要借助transtrom的tanslateX方法)。 123456789#parent&#123; position: relative;&#125;#child&#123; position: absolute; top: 0; left: 50%; transform: translateX(-50%);&#125; 方法四：利用flex弹性布局的一个属性。 子元素宽度已知的情况下1234#parent&#123; display: flex; justify-content: center;&#125; 其他还有很多方法，一般用的不太多。并且各种方法优缺点不一样，可选择性使用。 2. 水平居中及垂直居中方法一：先说一种神奇的方式吧12341. 子元素 div 绝对定位2. 父元素需要被定位3. 子元素 top、bottom、left、right 四个位置值均为 04. 子元素 margin: auto; 下面代码是可以实现的，但还有点问题，大家帮小花看看~ 12345678910111213141516#parent&#123; width: 100%; height:100%; position: fixed;&#125;#child&#123; width: 400px; height: 200px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; background-color: #ccc;&#125; 方式二：利用position的绝对定位及负边框来实现。123456789101112131415 #parent&#123; position: fixed; width: 100%; height: 100%;&#125;#child&#123; position: absolute; left: 50%; top: 50%; width: 400px; height: 200px; margin-top: -100px; margin-left: -200px; background-color: #ccc;&#125; 对于未给出宽高的元素，又需要请transform登场了，同时需要做好各浏览器的兼容。对于我这种懒癌患者，就不给出兼容代码嘞~ 其他应该还有一些方法，暂时还没想到，等写出来了再补补（哦对了，忘了说flex了，算了还是不写了） 3. 左边固定右边自适应的两列布局我猜吧，大家对这种布局方式最熟悉不过了，平时用的也会比较多，所以呢，你们写的应该都会比我的好~ 方式一：float+margin的方式 这种方式一定要记得给父元素清除浮动啊，不然就尴尬了呢，这里插播一种全局性(这个词似乎不太对)的清除浮动的伪元素方法.1234567891011.clearfix:after &#123; content: &apos;.&apos;; height: 0; overflow: hidden; clear: both; display: block; visibility: hidden;&#125;.clearfix &#123; zoom: 1; &lt;!--hack--&gt;&#125; 看起来有点小复杂啊，这里不分析这种方法的原理，记住就好了。当然你也可以直接借助触发BFC的方式来解决（偷偷告诉你，常用的方式就是给你的父元素设置overflow: hidden;啦）。 哦+语气~好像跑偏了，说好的布局呢，见下诉代码： 1234567#left&#123; float: left; width: 100px;&#125;#right&#123; margin-left: 120px;&#125; 方式二：float+overflow的方式 这就是传说中利用BFC的规则来实现两列布局啊啊啊！ 这种方式直接不需要清除浮动什么的就可以了，也不会影响前后文，用起来比较爽丫。12345678#left&#123; float: left; width: 100px; margin-right: 20px; &lt;!--好歹留个空啊嘿嘿--&gt;&#125;#right&#123; overflow: hidden;&#125; 方式三：float+margin+position的方式 这个方式呢也用到过，但是要考虑的比较多一点，不过其实也还好。接下来请看实现代码：1234567891011121314#parent&#123; position: relative;&#125;#left&#123; float: left; width: 100px; background-color: #ccc;&#125;#right&#123; position: absolute; top: 0; left: 120px; background-color:pink;&#125; 这种方式实现起来很简单，但是对后文是有影响的，需要自己解决一下，懒小花就不写啦~ 方式四：flex方式 这个呢，坑肯定是比较多的，建议用在小范围的布局，当然某些时候用起来确实比较爽歪歪啦12345678910#parent&#123; display: flex;&#125;#left&#123; width: 100px; margin-right: 20px;&#125;#right&#123; flex: 1;&#125; 其他的吧，我暂时还没用到也没写到~网上一搜会有好多好多精讲的。 4. 左边自适应右边固定话说其实我就只写了一种方法，我都有点不好意思放上来了，不管了，小花的脸皮比较厚，不怕！ 方式一： 当然还是position 反正很多情况都可以用position来解决，但是，同时也会有一些其他问题出现，所以，自行思考用不用~123456789101112#parent &#123; position: relative;&#125;#left &#123; margin-right:220px;&#125;#right &#123; position: absolute; right:0; top:0; width: 200px;&#125; 5. 两边固定中间自适应的三列布局其实这个布局用的也挺多的啊哈，嗯，昨天写的作业就是这个！ 方式一：纯float方式注意： 左侧元素与右侧元素优先渲染，分别向左和向右浮动 中间元素在文档流的最后渲染，自动插入到左右两列元素的中间，随后设置 margin 左右边距分别为左右两列的宽度，将中间元素调整到正确的位置。 12345678910111213.left&#123; float: left; width: 200px; height: 200px;&#125;.right&#123; float: right; width: 100px; height: 100px;&#125;.middle&#123; margin:0 120px 0 220px;&#125; 但凡用float的时候都要想一下父元素上清除浮动这个问题！ 方式二：position的绝对定位 其实感觉跟float的原理差不多，都是将左右两侧的块先固定好，再对中间部分进行处理，只不过自己可以在不同情况下选择float或者position。 1234567891011121314151617181920.parent&#123; position: relative;&#125;.left&#123; position: absolute; width: 200px; height: 200px; top: 0; left: 0;&#125;.right&#123; position: absolute; top: 0; right: 0; width: 100px; height: 100px;&#125;.middle&#123; margin:0 120px 0 220px;&#125; 方式三：flex的弹性布局 不得不说的是其实很多布局都可以用flex来实现(简单粗暴嘿嘿)，但是flex的兼容性不是很好，并且还有别问题，所以保险起见还是选择常用的，这里简单介绍下。123456789101112131415.parent&#123; display: flex;&#125;.left&#123; width: 200px; height: 200px;&#125;.right&#123; width: 100px; height: 100px;&#125;.middle&#123; flex: 1; margin:0 20px;&#125; 方式四：最后该淘宝的双翼布局闪亮登场了 要注意的是这种布局方式需要将主栏优先渲染，然后再加上两边的翅膀，即双翼，不过话又说话来，虽然小花是按照这个套路写的，但也不确定自己写的就是双翼布局。为了不误人子弟，在这先说明只是参考参考哟（欢迎大佬纠正）~ 第一步，先将主栏左浮动，并设宽度为100%，即铺满父元素 第二步，将左栏左浮动，并设左外边距为-100% 第三步，将右栏左浮动，并设左外边距为负的自身宽度 第四步，设置主栏，嘿嘿，这时候不管你使用什么方法都达不到效果，解决办法就是给主栏的内容加一个包裹层，并设左右外边距为左右两侧的宽度。 第五步，好了，完美！（但是别忘了，要清除浮动哦~） 6. 是时候小结一波了 首先，每种方式都小试了一下，基本上效果是可以达到的，当然实际情况中会比较复杂，你会遇到各种各样的麻烦，祝你好运~ 每种方式的优缺点其实对于我这种萌新来说也是比较懵，只是这几天写了几个作业才想到要小小总结下的 第一次用markdown写文字棒棒哒，不要介意某写地方可能写错了","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"CSS布局","slug":"CSS布局","permalink":"http://visugar.com/tags/CSS布局/"},{"name":"web","slug":"web","permalink":"http://visugar.com/tags/web/"}]},{"title":"hexo从零开始到搭建完整","slug":"20170504SetUpHexoBlog","date":"2017-05-04T08:16:15.000Z","updated":"2017-08-29T11:23:44.441Z","comments":true,"path":"2017/05/04/20170504SetUpHexoBlog/","link":"","permalink":"http://visugar.com/2017/05/04/20170504SetUpHexoBlog/","excerpt":"前言其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放","text":"前言其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放，不好找，所以才想着自己搭建一个人博客网站，现在大家用hexo比较多，也比较方便，并且能使用的主题也很多，所以小花就用她啦~ 本篇为从零开始的基础篇，其他SEO、评论系统、统计等请看Hexo博客添加SEO-评论系统-阅读统计-站长统计，本篇所包含的内容如下： 安装Git Bash 安装NodeJs 安装hexo 生成SSH并添加到github 部署项目 上传到github 绑定个人域名 修改及配置主题 添加RSS 添加评论 写文章部分 耍起来由于小花的电脑在搭建博客之前就有了各种环境，但是对于没有任何基础的人来讲，我觉得还是从源头开始讲会好一点，就像教别人做菜，总得把所有的用料及步骤说清楚对吧？（大佬们可以自动忽略啊啊啊啊~） 1. 安装Git Bash我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。下载地址 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本： 命令：git version (写这篇博客的时候最新版本：2.12.2) 然后你就可以在这里发挥你的聪明才智了 2. 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧 下载地址(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。 查看版本：1命令：node -v 又到自由发挥的时候了 3. 安装hexo看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：1npm i -g hexo 安装完成后，查看版本： 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 做好这些前置工作之后接下来的就是各种配配配置了。 4. 生成SSH并添加到github没账号的创建账号，有账号的看下面。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下： 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）： 创建SSH 在gitbash中输入：ssh-keygen -t rsa -C &quot;youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。 将上面获取的ssh放到github中： 添加一个 New SSH key ，title随便取，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com 完成下一步你就成功啦！ 5. 部署项目用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令：123hexo cleanhexo generatehexo server 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。 打开浏览器输入：http://localhost:4000 接着你就可以遇见天使的微笑了~ 6. 上传到github先安装一波：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)：123hexo cleanhexo generatehexo deploy 注意deploy的过程中要输入你的username及passward。如下： 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！ 感觉gitbash中东西太多的时候输入clear命令清空。 7. 绑定个人域名不想绑定的自行忽略 第一步购买域名：随便在哪个网站买一个就好了，小花是在阿里云购买的visugar.com, DNS也是顺道在那买的。 第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是visugar.com，只能添加一个哦。 到DNS中添加一条记录： 其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)： 接着再次部署一下，用你购买的域名打开，就可以看到你的博客啦~ 8. 修改及配置主题hexo初始化之后默认的主题是landscape , 然后你可以去这个地址里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是hueman,看起来挺不错，至少是我喜欢的类型。 跟该主题相关的配置在themes/hueman/_config.yml里面,然后根据你的需要在这配配配就行了。 有的东西我也不知道是啥玩意儿，你要多试多倒腾几次，就能意会啦!下面是针对我所选的主题的两小点(别的主题我没看，可能也是类似: 在导航栏添加点东西 例如我添加了一个更新日志的模块。 在主题的配置文件中，menu添加一栏：Board: /board。 然后在source中添加一个board，即对应上面的名字。然后再创建一个index.md，里面可以写你想写的内容。 在主题的hueman/langulages/zh-CN.yml中的index适当的位置加：board: &#39;更新日志&#39;，位置和名字是你自己设定。 重新部署，然后就OK了 在侧边栏添加点东西 回到你的主题的配置文件中，找到widgets一栏，在你要添加的位置处添加一条你自定义的名称。例如我的叫communiation且放在了第二行。 在上面所提到的zh-CN.yml文件中找到sidebar一栏，添加communiation: &#39;你要设的名称&#39;。 在hueman/layout/widget中添加一个communiation.ejs,填入模板12345678&lt;% if (site.posts.length) &#123; %&gt; &lt;div class=&quot;widget-wrap widget-list&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&apos;sidebar.communiation&apos;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;!--这里添加你要写的内容--&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 9. 添加RSS先安装rss相关插件：npm i hexo-generator-feed 在你的项目的_config.yml配置文件下找到Extensions添加如下内容： 1234567891011# Extensions #插件和主题## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 进入到你的主题的配置文件下，找到你的放rss的位置，添加/atom.xml即可。 重新部署再打开就能看到效果啦~ 10. 添加评论20170812更新：云更贴已在2017年8月1日停止服务，具体评论系统文章统计站长统计及百度SEO谷歌SEO什么的可参考Hexo博客添加SEO-评论系统-阅读统计-站长统计 此段已失效。 先选一个你要使用的第三方评论系统，最好找个靠谱点的（我使用的是网易云跟帖）。 在主题的配置文件下找到comment，添加一行，例如我添加的是yungentie: 此处自由发挥 注册完评论系统后获取相应的代码，然后在主题的layout下找到comment新建一个ejs模板文件，名称自定义。 找到你的article.ejs模板文件，加上&lt;%- partial(&#39;comment/你刚刚取得名字&#39;) %&gt;保存。 重新部署，OK啦 11. 写文章部分 新建文章：hexo new &#39;文章名&#39;，然后你就可以在source/_posts路径下看到你创建的文章啦，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。 关于具体的文章编辑你可以看下官网的介绍 至于markdown，可以自行发挥啦~ 小结一波 在哪里跌倒，就在哪里趴下，休息一会儿你会发现新大陆的哦~ 本文针对的是从来没用hexo搭建过个人博客的小伙伴，不过文中可能会有一些小错误，欢迎大佬们指正，小花不胜感激！ 感觉我好啰嗦啊，可是没办法，我就是这么爱打字丫","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"hexo","slug":"hexo","permalink":"http://visugar.com/tags/hexo/"},{"name":"hueman","slug":"hueman","permalink":"http://visugar.com/tags/hueman/"}]}]}